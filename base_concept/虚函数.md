# 虚函数

---

虚函数（Virtual Function）是C++中实现**多态性**（Polymorphism）的一种机制。多态性允许你使用基类的指针或引用来调用派生类的成员函数，从而在运行时决定调用哪个函数。虚函数通过虚函数表（Virtual Table，简称vtable）来实现这种动态绑定。

### 虚函数的定义

在基类中，你可以将一个成员函数声明为虚函数，使用 `virtual` 关键字：

```cpp
class Base {
public:
    virtual void show() {
        std::cout << "Base class show function" << std::endl;
    }
};
```

在派生类中，你可以重写（Override）这个虚函数：

```cpp
class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class show function" << std::endl;
    }
};
```

### 虚函数的特点

1. **动态绑定**：虚函数允许在[运行时决定调用哪个函数，而不是在编译时决定](#为什么说-虚函数允许在运行时决定调用哪个函数而不是在编译时决定)。这称为动态绑定（Dynamic Binding）或晚期绑定（Late Binding）。
2. **多态性**：通过基类的指针或引用调用虚函数时，实际调用的是派生类的重写函数。这实现了多态性。
3. **`override` 关键字**：在派生类中重写虚函数时，建议使用 `override` 关键字，以确保你确实是在重写基类的虚函数，而不是定义一个新的函数。
4. **纯虚函数**：如果一个虚函数没有实现（即没有函数体），它被称为纯虚函数（Pure Virtual Function）。包含纯虚函数的类是抽象类（Abstract Class），不能实例化。

### 示例代码

以下是一个简单的示例，展示了如何使用虚函数实现多态性：

```cpp
#include <iostream>

class Base {
public:
    virtual void show() {
        std::cout << "Base class show function" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class show function" << std::endl;
    }
};

int main() {
    Base* basePtr;
    Derived derivedObj;

    basePtr = &derivedObj;  // 基类指针指向派生类对象
    basePtr->show();        // 调用派生类的 show 函数

    return 0;
}
```

### 输出结果

```
Derived class show function
```

### 解释

1. **基类和派生类**：`Base` 是基类，`Derived` 是派生类。
2. **虚函数**：`Base` 类中的 `show` 函数被声明为虚函数。
3. **重写虚函数**：`Derived` 类重写了 `show` 函数。
4. **多态性**：在 `main` 函数中，基类指针 `basePtr` 指向派生类对象 `derivedObj`。通过 `basePtr->show()` 调用的是派生类的 `show` 函数，而不是基类的 `show` 函数。

### 纯虚函数和抽象类

如果一个类包含纯虚函数，它就成为了抽象类，不能实例化。纯虚函数的定义如下：

```cpp
class AbstractBase {
public:
    virtual void show() = 0;  // 纯虚函数
};
```

派生类必须实现纯虚函数，否则它也会成为抽象类。

### 示例代码

以下是一个包含纯虚函数的示例：

```cpp
#include <iostream>

class AbstractBase {
public:
    virtual void show() = 0;  // 纯虚函数
};

class Derived : public AbstractBase {
public:
    void show() override {
        std::cout << "Derived class show function" << std::endl;
    }
};

int main() {
    // AbstractBase obj;  // 错误：不能实例化抽象类
    Derived derivedObj;
    derivedObj.show();  // 调用派生类的 show 函数

    return 0;
}
```

### 输出结果

```
Derived class show function
```

### 解释

1. **抽象类**：`AbstractBase` 是一个抽象类，因为它包含一个纯虚函数 `show`。
2. **派生类**：`Derived` 类实现了 `show` 函数，因此可以实例化。
3. **实例化**：在 `main` 函数中，`Derived` 类的对象 `derivedObj` 可以实例化并调用 `show` 函数。

### 总结

- **虚函数**：用于实现多态性，允许在运行时决定调用哪个函数。
- **动态绑定**：虚函数通过虚函数表实现动态绑定。
- **多态性**：通过基类的指针或引用调用虚函数时，实际调用的是派生类的重写函数。
- **纯虚函数**：没有实现的虚函数，使类成为抽象类，不能实例化。
- **抽象类**：包含纯虚函数的类，不能实例化，派生类必须实现纯虚函数。


<br>

<br>

<br>




# 解释

---


## 为什么说 “虚函数允许在运行时决定调用哪个函数，而不是在编译时决定”

这句话的意思是，虚函数的调用是在程序运行时（Runtime）根据对象的实际类型来决定的，而不是在编译时（Compile-time）根据指针或引用的类型来决定的。这种机制称为动态绑定（Dynamic Binding）或晚期绑定（Late Binding）。

### 为什么要在运行时决定？

1. **多态性**：
   - 多态性是面向对象编程的一个重要特性，它允许你使用基类的指针或引用来调用派生类的成员函数。
   - 通过在运行时决定调用哪个函数，你可以编写更通用的代码，而不需要知道对象的具体类型。

2. **灵活性**：
   - 在运行时决定调用哪个函数，使得代码更加灵活。你可以根据对象的实际类型来执行不同的操作，而不需要修改代码。
   - 这对于处理复杂对象层次结构和动态对象创建非常有用。

3. **扩展性**：
   - 通过虚函数，你可以轻松地扩展类的层次结构，添加新的派生类，而不需要修改现有的代码。
   - 新的派生类可以重写虚函数，从而改变对象的行为，而不影响其他部分的代码。

### 示例代码

以下是一个简单的示例，展示了虚函数如何在运行时决定调用哪个函数：

```cpp
#include <iostream>

class Base {
public:
    virtual void show() {
        std::cout << "Base class show function" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class show function" << std::endl;
    }
};

void callShow(Base* basePtr) {
    basePtr->show();  // 在运行时决定调用哪个 show 函数
}

int main() {
    Base baseObj;
    Derived derivedObj;

    callShow(&baseObj);    // 调用基类的 show 函数
    callShow(&derivedObj); // 调用派生类的 show 函数

    return 0;
}
```

### 输出结果

```
Base class show function
Derived class show function
```

### 解释

1. **基类和派生类**：`Base` 是基类，`Derived` 是派生类。
2. **虚函数**：`Base` 类中的 `show` 函数被声明为虚函数。
3. **重写虚函数**：`Derived` 类重写了 `show` 函数。
4. **多态性**：在 `main` 函数中，`callShow` 函数接受一个 `Base*` 类型的参数。根据传入的实际对象类型（`baseObj` 或 `derivedObj`），在运行时决定调用哪个 `show` 函数。

### 动态绑定的工作原理

1. **虚函数表（vtable）**：
   - 每个包含虚函数的类都有一个虚函数表（vtable），它是一个函数指针数组，存储了该类的虚函数的地址。
   - 每个对象都有一个指向其类的虚函数表的指针（vptr）。

2. **运行时查找**：
   - 当通过基类的指针或引用调用虚函数时，程序会通过对象的 vptr 找到对应的 vtable。
   - 然后，根据虚函数的索引，从 vtable 中找到实际要调用的函数地址，并调用该函数。

### 示例代码（虚函数表的简化示意）

```cpp
class Base {
public:
    virtual void show() {
        std::cout << "Base class show function" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class show function" << std::endl;
    }
};

int main() {
    Base* basePtr;
    Derived derivedObj;

    basePtr = &derivedObj;  // 基类指针指向派生类对象
    basePtr->show();        // 调用派生类的 show 函数

    return 0;
}
```

### 解释

1. **虚函数表**：
   - `Base` 类有一个虚函数表，其中包含 `show` 函数的地址。
   - `Derived` 类继承了 `Base` 类的虚函数表，并重写了 `show` 函数的地址。

2. **运行时查找**：
   - 当 `basePtr->show()` 被调用时，程序通过 `derivedObj` 的 vptr 找到 `Derived` 类的虚函数表。
   - 然后，根据 `show` 函数的索引，从虚函数表中找到 `Derived` 类的 `show` 函数地址，并调用该函数。

### 总结

- **运行时决定**：虚函数的调用是在运行时根据对象的实际类型决定的，而不是在编译时根据指针或引用的类型决定的。
- **多态性**：通过虚函数，你可以使用基类的指针或引用来调用派生类的成员函数，从而实现多态性。
- **灵活性和扩展性**：在运行时决定调用哪个函数，使得代码更加灵活和易于扩展。
