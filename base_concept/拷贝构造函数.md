# 拷贝构造函数

---

拷贝构造函数（Copy Constructor）是C++中的一种特殊成员函数，用于创建一个对象的副本。**当你将一个对象赋值给另一个对象时，或者将一个对象作为参数传递给函数时**，编译器会自动调用**拷贝构造函数**来创建对象的副本。

### 拷贝构造函数的定义

拷贝构造函数的形式如下：

```cpp
class MyClass {
public:
    // 拷贝构造函数
    MyClass(const MyClass& other) {
        // 从 other 对象中复制数据到当前对象
    }
};
```

<br>

### 拷贝构造函数的特点

1. **参数类型**：拷贝构造函数的参数==必须是引用类型==   ，[通常是 `const` 引用，以避免无限递归调用](#为什么说const-引用可以避免无限递归调用)。
2. **默认拷贝构造函数**：如果你没有显式定义拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数，它执行的是浅拷贝（shallow copy），即逐成员复制。
3. **深拷贝**：如果你需要执行深拷贝（deep copy），即复制对象的所有数据成员，包括动态分配的内存，你需要自己定义拷贝构造函数。

<br>

### 示例代码

以下是一个简单的示例，展示了如何定义和使用拷贝构造函数：

```cpp
#include <iostream>
#include <string>

class MyClass {
public:
    int value;
    std::string name;

    // 构造函数
    MyClass(int v = 0, const std::string& n = "") : value(v), name(n) {
        std::cout << "Constructor called for " << name << std::endl;
    }

    // 拷贝构造函数
    MyClass(const MyClass& other) : value(other.value), name(other.name) {
        std::cout << "Copy constructor called for " << name << std::endl;
    }

    // 析构函数
    ~MyClass() {
        std::cout << "Destructor called for " << name << std::endl;
    }
};

int main() {
    MyClass obj1(42, "obj1");  // 调用构造函数
    MyClass obj2 = obj1;       // 调用拷贝构造函数

    std::cout << "obj1.value: " << obj1.value << ", obj1.name: " << obj1.name << std::endl;
    std::cout << "obj2.value: " << obj2.value << ", obj2.name: " << obj2.name << std::endl;

    return 0;
}
```

### 输出结果

```
Constructor called for obj1
Copy constructor called for obj1
obj1.value: 42, obj1.name: obj1
obj2.value: 42, obj2.name: obj1
Destructor called for obj1
Destructor called for obj1
```

### 解释

1. **构造函数**：`MyClass(int v = 0, const std::string& n = "")` 是构造函数，用于初始化对象。
2. **拷贝构造函数**：`MyClass(const MyClass& other)` 是拷贝构造函数，用于创建对象的副本。
3. **析构函数**：`~MyClass()` 是析构函数，用于在对象销毁时执行清理操作。
4. **拷贝构造函数的调用**：在 `main` 函数中，`MyClass obj2 = obj1;` 调用了拷贝构造函数，创建了 `obj1` 的副本 `obj2`。

### 总结

- 拷贝构造函数用于创建对象的副本。
- 拷贝构造函数的参数必须是引用类型，通常是 `const` 引用。
- 如果你没有显式定义拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数，执行浅拷贝。
- 如果你需要执行深拷贝，你需要自己定义拷贝构造函数。


<br>
<br>

<br>
<br>


# 解释

---

## 为什么说const 引用，可以避免无限递归调用？

在C++中，拷贝构造函数的参数通常是 `const` 引用类型，这样可以避免无限递归调用。让我们详细解释一下原因。

### 为什么使用引用类型

1. **避免无限递归调用**：
   - 如果拷贝构造函数的参数不是引用类型，而是值类型，那么在调用拷贝构造函数时，编译器会首先创建一个临时对象，这个临时对象是原对象的副本。
   - 为了创建这个临时对象，编译器会再次调用拷贝构造函数，从而导致无限递归调用，最终导致栈溢出。

### 示例代码

假设我们有一个类 `MyClass`，并且我们尝试定义一个拷贝构造函数，但参数不是引用类型：

```cpp
class MyClass {
public:
    int value;

    // 错误的拷贝构造函数定义
    MyClass(MyClass other) {  // 注意：参数不是引用类型
        value = other.value;
    }
};
```

在这个例子中，`MyClass(MyClass other)` 的参数 `other` 是**值类型**，而不是引用类型。当我们尝试创建一个对象的副本时：

```cpp
MyClass obj1(42);
MyClass obj2 = obj1;  // 调用拷贝构造函数
```

编译器会首先创建一个临时对象 `other`，这个临时对象是 `obj1` 的副本。为了创建这个临时对象，编译器会再次调用拷贝构造函数，从而导致无限递归调用。
>如果我硬要使用 [值传递构建 拷贝构造函数](#要想通过值传递也是合法的-拷贝构造)

### 使用引用类型

为了避免无限递归调用，我们应该将拷贝构造函数的参数定义为引用类型：

```cpp
class MyClass {
public:
    int value;

    // 正确的拷贝构造函数定义
    MyClass(const MyClass& other) {  // 注意：参数是 const 引用类型
        value = other.value;
    }
};
```

在这个例子中，`MyClass(const MyClass& other)` 的参数 `other` 是 `const` 引用类型。当我们尝试创建一个对象的副本时：

```cpp
MyClass obj1(42);
MyClass obj2 = obj1;  // 调用拷贝构造函数
```

编译器不会创建临时对象，而是直接将 `obj1` 的引用传递给拷贝构造函数。这样就避免了无限递归调用。

### 为什么使用 `const`

1. **避免修改原对象**：
   - 使用 `const` 引用可以确保在拷贝构造函数中不会意外修改原对象。
   - 这符合拷贝构造函数的语义，即创建一个对象的副本，而不改变原对象的状态。

### 总结

- **引用类型**：拷贝构造函数的参数必须是引用类型，以避免无限递归调用。
- **`const` 引用**：使用 `const` 引用可以确保在拷贝构造函数中不会修改原对象，并且符合拷贝构造函数的语义。

通过使用 `const` 引用类型作为拷贝构造函数的参数，我们可以避免无限递归调用，并且确保拷贝构造函数的行为符合预期。



<br>
<br>

<br>
<br>


## 要想通过值传递，也是合法的 拷贝构造

```cpp

MyClass(int val){
    value = new int(val);   //深拷贝构造
}

~MyClass(){
    delete value;   //切记堆内存需要自己手动 释放！！
}

```