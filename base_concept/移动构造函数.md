# 移动构造函数

---

移动构造函数（Move Constructor）是C++11引入的一种特殊成员函数，[用于将资源从一个对象“移动”到另一个对象，而**不是进行深拷贝**。这通常用于提高性能](#怎么理解-移动-移动构造函数-和-拷贝构造函数-的区别是什么)，特别是在处理动态分配的内存或大型数据结构时。

### 移动构造函数的形式

移动构造函数的形式如下：

```cpp
class MyClass {
public:
    // 移动构造函数
    MyClass(MyClass&& other) noexcept {
        // 从 other 对象中移动资源到当前对象
    }
};
```

### 关键点解释

1. **`&&` 符号**：表示[右值引用（Rvalue Reference）](#什么是右值引用)。右值引用允许你绑定到一个临时对象（右值），从而可以“窃取”它的资源。
2. **`noexcept` 关键字**：表示这个函数不会抛出异常。这有助于编译器进行一些优化，并且在某些情况下（如标准库容器）是必须的。

### 示例代码

以下是一个简单的示例，展示了如何定义和使用移动构造函数：

```cpp
#include <iostream>
#include <string>

class MyClass {
public:
    std::string* data;

    // 构造函数
    MyClass(const std::string& str) : data(new std::string(str)) {
        std::cout << "Constructor called for " << *data << std::endl;
    }

    // 移动构造函数
    MyClass(MyClass&& other) noexcept : data(other.data) {
        std::cout << "Move constructor called for " << *data << std::endl;
        other.data = nullptr;  // 将原对象的指针置空，避免重复释放
    }

    // 析构函数
    ~MyClass() {
        if (data) {
            std::cout << "Destructor called for " << *data << std::endl;
            delete data;
        } else {
            std::cout << "Destructor called for moved object" << std::endl;
        }
    }
};

int main() {
    MyClass obj1("Hello");  // 调用构造函数
    MyClass obj2 = std::move(obj1);  // 调用移动构造函数

    // obj1 的 data 指针已经被置空
    if (obj1.data == nullptr) {
        std::cout << "obj1 is now empty" << std::endl;
    }

    return 0;
}
```

### 输出结果

```
Constructor called for Hello
Move constructor called for Hello
obj1 is now empty
Destructor called for moved object
Destructor called for Hello
```

### 解释

1. **构造函数**：`MyClass(const std::string& str)` 是构造函数，用于初始化对象。
2. **移动构造函数**：`MyClass(MyClass&& other) noexcept` 是移动构造函数，用于将资源从 `other` 对象移动到当前对象。
3. **析构函数**：`~MyClass()` 是析构函数，用于在对象销毁时执行清理操作。
4. **移动构造函数的调用**：在 `main` 函数中，`MyClass obj2 = std::move(obj1);` 调用了移动构造函数，将 `obj1` 的资源移动到 `obj2`。

### 总结

- **移动构造函数**：用于将资源从一个对象“移动”到另一个对象，而不是进行深拷贝。
- **`&&` 符号**：表示右值引用，允许绑定到临时对象。
- **`noexcept` 关键字**：表示这个函数不会抛出异常，有助于编译器优化。

通过使用移动构造函数，你可以显著提高性能，特别是在处理动态分配的内存或大型数据结构时。


<br>
<br>


<br>
<br>



# 解释

---


## 什么是右值引用

右值引用（Rvalue Reference）是C++11引入的一种新的引用类型，用于支持移动语义（Move Semantics）和完美转发（Perfect Forwarding）。右值引用允许你绑定到一个临时对象（右值），从而可以“窃取”它的资源，而不是进行深拷贝。

### 右值引用的语法

右值引用使用 `&&` 符号表示。例如：

```cpp
int&& rvalue_ref = 42;  // 右值引用绑定到一个临时对象
```

### 右值和左值

在C++中，表达式可以分为两种类型：

1. **左值（Lvalue）**：
   - 左值是指可以出现在赋值运算符左侧的表达式，通常表示一个有名字的对象。
   - 例如：变量、数组元素、返回左值引用的函数调用等。

2. **右值（Rvalue）**：
   - 右值是指只能出现在赋值运算符右侧的表达式，通常表示一个临时对象或字面量。
   - 例如：字面量、返回非引用类型的函数调用、临时对象等。

### 右值引用的作用

1. **支持移动语义**：
   - 右值引用允许你定义移动构造函数和移动赋值运算符，从而可以将资源从一个对象“移动”到另一个对象，而不是进行深拷贝。
   - 这可以显著提高性能，特别是在处理动态分配的内存或大型数据结构时。

2. **支持完美转发**：
   - 右值引用允许你编写泛型代码，能够完美地转发参数，保持参数的值类别（左值或右值）不变。
   - 这通常用于模板编程，特别是在实现工厂函数或包装器时。

### 示例代码

以下是一个简单的示例，展示了如何使用右值引用和移动语义：

```cpp
#include <iostream>
#include <string>

class MyClass {
public:
    std::string* data;

    // 构造函数
    MyClass(const std::string& str) : data(new std::string(str)) {
        std::cout << "Constructor called for " << *data << std::endl;
    }

    // 移动构造函数
    MyClass(MyClass&& other) noexcept : data(other.data) {
        std::cout << "Move constructor called for " << *data << std::endl;
        other.data = nullptr;  // 将原对象的指针置空，避免重复释放
    }

    // 析构函数
    ~MyClass() {
        if (data) {
            std::cout << "Destructor called for " << *data << std::endl;
            delete data;
        } else {
            std::cout << "Destructor called for moved object" << std::endl;
        }
    }
};

int main() {
    MyClass obj1("Hello");  // 调用构造函数
    MyClass obj2 = std::move(obj1);  // 调用移动构造函数

    // obj1 的 data 指针已经被置空
    if (obj1.data == nullptr) {
        std::cout << "obj1 is now empty" << std::endl;
    }

    return 0;
}
```

### 输出结果

```
Constructor called for Hello
Move constructor called for Hello
obj1 is now empty
Destructor called for moved object
Destructor called for Hello
```

### 解释

1. **构造函数**：`MyClass(const std::string& str)` 是构造函数，用于初始化对象。
2. **移动构造函数**：`MyClass(MyClass&& other) noexcept` 是移动构造函数，用于将资源从 `other` 对象移动到当前对象。
3. **析构函数**：`~MyClass()` 是析构函数，用于在对象销毁时执行清理操作。
4. **移动构造函数的调用**：在 `main` 函数中，`MyClass obj2 = std::move(obj1);` 调用了移动构造函数，将 `obj1` 的资源移动到 `obj2`。

### 总结

- **右值引用**：使用 `&&` 符号表示，允许绑定到临时对象（右值）。
- **移动语义**：右值引用支持移动构造函数和移动赋值运算符，从而可以将资源从一个对象“移动”到另一个对象，而不是进行深拷贝。
- **完美转发**：右值引用允许编写泛型代码，能够完美地转发参数，保持参数的值类别（左值或右值）不变。

<br>

<br>

<br>


## 怎么理解 “移动”? 移动构造函数 和 拷贝构造函数 的区别是什么?

在C++中，“移动”（Move）是指将资源的所有权从一个对象转移到另一个对象，而不是进行深拷贝。移动构造函数（Move Constructor）和拷贝构造函数（Copy Constructor）的主要区别在于它们处理资源的方式。

### 移动构造函数

移动构造函数是C++11引入的一种特殊成员函数，用于将资源从一个对象“移动”到另一个对象。移动构造函数的语法如下：

```cpp
class MyClass {
public:
    // 移动构造函数
    MyClass(MyClass&& other) noexcept {
        // 从 other 对象中移动资源到当前对象
    }
};
```

#### 移动构造函数的特点

1. **右值引用**：移动构造函数的参数是右值引用（`&&`），表示它可以绑定到临时对象（右值）。
2. **资源转移**：移动构造函数将资源的所有权从一个对象转移到另一个对象，而不是进行深拷贝。这通常涉及将指针或资源句柄从一个对象转移到另一个对象，并将原对象的指针置空。
3. **性能优化**：移动构造函数可以显著提高性能，特别是在处理动态分配的内存或大型数据结构时。

### 拷贝构造函数

拷贝构造函数是用于创建对象副本的特殊成员函数。拷贝构造函数的语法如下：

```cpp
class MyClass {
public:
    // 拷贝构造函数
    MyClass(const MyClass& other) {
        // 从 other 对象中复制数据到当前对象
    }
};
```

#### 拷贝构造函数的特点

1. **左值引用**：拷贝构造函数的参数是 `const` 左值引用（`const &`），表示它可以绑定到任何对象（左值或右值）。
2. **深拷贝**：拷贝构造函数通常执行深拷贝，即复制对象的所有数据成员，包括动态分配的内存。这可能会导致性能开销，特别是在处理大型数据结构时。

### 示例代码

以下是一个简单的示例，展示了移动构造函数和拷贝构造函数的区别：

```cpp
#include <iostream>
#include <string>

class MyClass {
public:
    std::string* data;

    // 构造函数
    MyClass(const std::string& str) : data(new std::string(str)) {
        std::cout << "Constructor called for " << *data << std::endl;
    }

    // 拷贝构造函数
    MyClass(const MyClass& other) : data(new std::string(*other.data)) {
        std::cout << "Copy constructor called for " << *data << std::endl;
    }

    // 移动构造函数
    MyClass(MyClass&& other) noexcept : data(other.data) {
        std::cout << "Move constructor called for " << *data << std::endl;
        other.data = nullptr;  // 将原对象的指针置空，避免重复释放
    }

    // 析构函数
    ~MyClass() {
        if (data) {
            std::cout << "Destructor called for " << *data << std::endl;
            delete data;
        } else {
            std::cout << "Destructor called for moved object" << std::endl;
        }
    }
};

int main() {
    MyClass obj1("Hello");  // 调用构造函数
    MyClass obj2 = obj1;    // 调用拷贝构造函数
    MyClass obj3 = std::move(obj1);  // 调用移动构造函数

    // obj1 的 data 指针已经被置空
    if (obj1.data == nullptr) {
        std::cout << "obj1 is now empty" << std::endl;
    }

    return 0;
}
```

### 输出结果

```
Constructor called for Hello
Copy constructor called for Hello
Move constructor called for Hello
obj1 is now empty
Destructor called for moved object
Destructor called for Hello
Destructor called for Hello
```

### 解释

1. **构造函数**：`MyClass(const std::string& str)` 是构造函数，用于初始化对象。
2. **拷贝构造函数**：`MyClass(const MyClass& other)` 是拷贝构造函数，用于创建对象的副本。
3. **移动构造函数**：`MyClass(MyClass&& other) noexcept` 是移动构造函数，用于将资源从 `other` 对象移动到当前对象。
4. **析构函数**：`~MyClass()` 是析构函数，用于在对象销毁时执行清理操作。
5. **拷贝构造函数的调用**：在 `main` 函数中，`MyClass obj2 = obj1;` 调用了拷贝构造函数，创建了 `obj1` 的副本 `obj2`。
6. **移动构造函数的调用**：在 `main` 函数中，`MyClass obj3 = std::move(obj1);` 调用了移动构造函数，将 `obj1` 的资源移动到 `obj3`。

### 总结

- **移动构造函数**：用于将资源从一个对象“移动”到另一个对象，而不是进行深拷贝。移动构造函数的参数是右值引用（`&&`）。
- **拷贝构造函数**：用于创建对象的副本，通常执行深拷贝。拷贝构造函数的参数是 `const` 左值引用（`const &`）。
- **资源转移 vs 深拷贝**：移动构造函数将资源的所有权从一个对象转移到另一个对象，而拷贝构造函数复制对象的所有数据成员。
- **性能优化**：移动构造函数可以显著提高性能，特别是在处理动态分配的内存或大型数据结构时。
